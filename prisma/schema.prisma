// Basecamp - KOL Agency Management Platform
// Database schema for PostgreSQL

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// ORGANIZATIONS & USERS
// ============================================

enum OrganizationType {
  AGENCY
  CLIENT
}

enum OrganizationRole {
  OWNER
  ADMIN
  MEMBER
  VIEWER
}

model Organization {
  id        String           @id @default(cuid())
  name      String
  slug      String           @unique
  type      OrganizationType
  logoUrl   String?
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt

  // Twitter/X API credentials for scraping
  twitterApiKey    String?  // twexapi.io or RapidAPI key
  twitterCookies   String?  // Browser cookies for direct API access
  twitterCsrfToken String?  // CSRF token for direct API
  apifyApiKey      String?  // Apify API key for Twitter scraping (fallback)
  socialDataApiKey String?  // SocialData.tools API key (primary)

  // Telegram bot integration
  telegramBotToken String?  // Bot token from @BotFather
  telegramBotUsername String?  // Bot username (e.g., @MyBot)
  telegramWebhookSecret String?  // Secret for verifying webhook calls

  members            OrganizationMember[]
  agencyCampaigns    Campaign[]           @relation("AgencyCampaigns")
  clientCampaigns    Campaign[]           @relation("ClientCampaigns")
  campaignClients    CampaignClient[]     @relation("CampaignClients")
  kols               KOL[]
  telegramChats      TelegramChat[]
  telegramBroadcasts TelegramBroadcast[]
  userInvitations    UserInvitation[]

  @@map("organizations")
}

model User {
  id               String    @id @default(cuid())
  email            String    @unique
  name             String?
  passwordHash     String?   // Optional - not needed for magic link auth
  emailVerified    DateTime? // When email was verified via magic link
  twitterUsername  String?
  telegramUsername String?
  avatarUrl        String?
  isDisabled       Boolean   @default(false) // Admin can disable users
  lastLoginAt      DateTime? // Track last login for security
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  // 2FA fields
  twoFactorEnabled Boolean   @default(false)
  twoFactorSecret  String?   // Encrypted TOTP secret
  backupCodes      String[]  @default([]) // Hashed backup codes

  memberships      OrganizationMember[]
  sentInvitations  UserInvitation[] @relation("SentInvitations")
  auditLogs        SecurityAuditLog[]

  @@map("users")
}

model OrganizationMember {
  id             String           @id @default(cuid())
  organizationId String
  userId         String
  role           OrganizationRole @default(MEMBER)
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt

  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([organizationId, userId])
  @@map("organization_members")
}

// Super Admin - separate from regular users
// Uses username/password auth only
model AdminUser {
  id           String    @id @default(cuid())
  email        String    @unique
  passwordHash String
  name         String?
  avatarUrl    String?
  twitterUsername String?  // X (Twitter) username
  role         AdminRole @default(USER)
  isActive     Boolean   @default(true)
  lastLoginAt  DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  // 2FA fields
  twoFactorEnabled Boolean   @default(false)
  twoFactorSecret  String?   // Encrypted TOTP secret
  backupCodes      String[]  // Hashed backup codes

  // Invitation tracking
  invitedBy    String?   // ID of admin who invited this user
  invitedAt    DateTime?

  @@map("admin_users")
}

enum AdminRole {
  SUPER_ADMIN  // Full access - can create/manage admin accounts
  USER         // Full access to all features except admin account management
  ADMIN        // Legacy - treated same as USER
  VIEWER       // Legacy - treated same as USER
}

// ============================================
// KOL MANAGEMENT
// ============================================

enum KOLTier {
  SMALL      // 1 - 10k followers
  MID        // 10,001 - 20k followers
  LARGE      // 20,001 - 74,999 followers
  MACRO      // 75k+ followers
  // Legacy tiers (for backwards compatibility)
  NANO       // Legacy: maps to SMALL
  MICRO      // Legacy: maps to MID
  RISING     // Legacy: maps to LARGE
  MEGA       // Legacy: maps to MACRO
}

enum KOLStatus {
  ACTIVE
  INACTIVE
  BLACKLISTED
  PENDING
}

model KOL {
  id                String    @id @default(cuid())
  organizationId    String
  name              String
  twitterHandle     String
  twitterId         String?
  avatarUrl         String?
  telegramUsername  String?
  telegramGroupId   String?   // Telegram group ID where KOL receives notifications
  email             String?
  tier              KOLTier   @default(SMALL)
  status            KOLStatus @default(ACTIVE)

  // Profile fields
  bio               String?
  categories        String[]  // e.g., ["DeFi", "Gaming", "NFT"]

  // Rates (stored as cents/smallest unit)
  ratePerPost       Int?
  ratePerThread     Int?
  ratePerRetweet    Int?
  ratePerSpace      Int?

  // Payment info
  walletAddress     String?
  paymentNotes      String?

  // Metrics (cached from Twitter API)
  followersCount    Int       @default(0)
  followingCount    Int       @default(0)
  avgEngagementRate Float     @default(0)
  avgLikes          Int       @default(0)
  avgRetweets       Int       @default(0)
  avgReplies        Int       @default(0)
  lastMetricsUpdate DateTime?

  // Notes
  notes             String?

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  organization      Organization       @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  tags              KOLTag[]           @relation("KOLTags")
  campaignKols      CampaignKOL[]
  posts             Post[]
  payments          Payment[]
  paymentReceipts   PaymentReceipt[]
  messages          TelegramMessage[]
  telegramChatLinks TelegramChatKOL[]
  followerSnapshots KOLFollowerSnapshot[]
  joinRequests      CampaignJoinRequest[]

  @@unique([organizationId, twitterHandle])
  @@map("kols")
}

model KOLTag {
  id             String   @id @default(cuid())
  name           String
  color          String   @default("#6366f1") // indigo
  organizationId String?
  createdAt      DateTime @default(now())

  kols KOL[] @relation("KOLTags")

  @@map("kol_tags")
}

// ============================================
// CAMPAIGNS
// ============================================

enum CampaignStatus {
  DRAFT
  PENDING_APPROVAL
  ACTIVE
  PAUSED
  COMPLETED
  CANCELLED
}

enum CampaignVisibility {
  PRIVATE  // Only assigned KOLs can see
  OPEN     // Any KOL can request to join
}

enum JoinRequestStatus {
  PENDING
  APPROVED
  DECLINED
  WITHDRAWN
}

enum CryptoNetwork {
  ETHEREUM
  POLYGON
  ARBITRUM
  OPTIMISM
  BASE
  BSC
  SOLANA
}

model Campaign {
  id          String         @id @default(cuid())
  agencyId    String
  clientId    String?

  name        String
  description String?

  // Project Twitter handle (e.g., @ProjectHandle)
  projectTwitterHandle String?
  projectAvatarUrl     String?
  projectBannerUrl     String?

  // Keywords for post tracking (e.g., ["$TOKEN", "#launch", "DEMO"])
  keywords    String[]

  // Client notification Telegram group chat ID
  clientTelegramChatId  String?

  // Budget (stored in cents)
  totalBudget Int            @default(0)
  spentBudget Int            @default(0)

  status      CampaignStatus @default(DRAFT)

  // KOL Portal visibility
  visibility          CampaignVisibility @default(PRIVATE)
  applicationDeadline DateTime?
  maxKolCount         Int?

  // Timeline
  startDate   DateTime?
  endDate     DateTime?

  // KPIs stored as JSON
  kpis        Json?          // { impressions: 1000000, engagement: 5 }

  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  agency          Organization   @relation("AgencyCampaigns", fields: [agencyId], references: [id], onDelete: Cascade)
  client          Organization?  @relation("ClientCampaigns", fields: [clientId], references: [id])
  campaignClients CampaignClient[]  // Many-to-many: multiple clients per campaign
  campaignKols    CampaignKOL[]
  posts           Post[]
  payments        Payment[]
  paymentReceipts PaymentReceipt[]
  joinRequests    CampaignJoinRequest[]
  documents       CampaignDocument[]

  @@map("campaigns")
}

enum CampaignKOLStatus {
  PENDING
  CONFIRMED
  DECLINED
  COMPLETED
}

// Junction table for many-to-many Campaign <-> Client relationship
model CampaignClient {
  id           String   @id @default(cuid())
  campaignId   String
  clientId     String   // Organization ID (type = CLIENT)
  createdAt    DateTime @default(now())

  campaign     Campaign     @relation(fields: [campaignId], references: [id], onDelete: Cascade)
  client       Organization @relation("CampaignClients", fields: [clientId], references: [id], onDelete: Cascade)

  @@unique([campaignId, clientId])
  @@map("campaign_clients")
}

model CampaignKOL {
  id             String            @id @default(cuid())
  campaignId     String
  kolId          String

  assignedBudget Int               @default(0) // cents
  status         CampaignKOLStatus @default(PENDING)

  // Structured deliverables tracking
  requiredPosts     Int            @default(0)
  requiredThreads   Int            @default(0)
  requiredRetweets  Int            @default(0)
  requiredSpaces    Int            @default(0)

  // Legacy deliverables JSON (kept for backward compatibility)
  deliverables   Json?             // [{ type: "post", quantity: 2 }, { type: "thread", quantity: 1 }]

  notes          String?

  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt

  campaign Campaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)
  kol      KOL      @relation(fields: [kolId], references: [id], onDelete: Cascade)

  @@unique([campaignId, kolId])
  @@map("campaign_kols")
}

// ============================================
// CONTENT TRACKING
// ============================================

enum PostType {
  POST
  THREAD
  RETWEET
  QUOTE
  SPACE
}

enum PostStatus {
  DRAFT
  PENDING_APPROVAL
  APPROVED
  REJECTED
  CHANGES_REQUESTED
  SCHEDULED
  POSTED
  VERIFIED
}

model Post {
  id           String     @id @default(cuid())
  campaignId   String
  kolId        String

  type         PostType   @default(POST)
  content      String?    // Draft content or verified content
  mediaUrls    String[]   // Array of media URLs

  // Twitter tracking
  tweetId      String?    @unique
  tweetUrl     String?

  status       PostStatus @default(DRAFT)

  // Schedule
  scheduledFor DateTime?
  postedAt     DateTime?

  // Keyword matching
  matchedKeywords String[]
  hasKeywordMatch Boolean  @default(false)

  // Metrics (cached from Twitter API)
  impressions  Int        @default(0)
  likes        Int        @default(0)
  retweets     Int        @default(0)
  replies      Int        @default(0)
  quotes       Int        @default(0)
  bookmarks    Int        @default(0)
  clicks       Int        @default(0)
  engagementRate Float    @default(0)
  lastMetricsUpdate DateTime?

  // Client feedback
  clientNotes  String?

  // Review page visibility (soft delete for review page only)
  hiddenFromReview Boolean @default(false)

  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt

  campaign Campaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)
  kol      KOL      @relation(fields: [kolId], references: [id], onDelete: Cascade)
  metricSnapshots PostMetricSnapshot[]

  @@map("posts")
}

// ============================================
// ANALYTICS SNAPSHOTS
// ============================================

model PostMetricSnapshot {
  id           String   @id @default(cuid())
  postId       String

  // Metrics at this point in time
  impressions  Int      @default(0)
  likes        Int      @default(0)
  retweets     Int      @default(0)
  replies      Int      @default(0)
  quotes       Int      @default(0)
  bookmarks    Int      @default(0)

  // Calculated
  engagementRate Float  @default(0)

  capturedAt   DateTime @default(now())

  post         Post     @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@index([postId, capturedAt])
  @@map("post_metric_snapshots")
}

model KOLFollowerSnapshot {
  id              String   @id @default(cuid())
  kolId           String

  followersCount  Int      @default(0)
  followingCount  Int      @default(0)

  // Daily change (calculated from previous snapshot)
  followersChange Int      @default(0)  // positive = gained, negative = lost

  capturedAt      DateTime @default(now())

  kol             KOL      @relation(fields: [kolId], references: [id], onDelete: Cascade)

  @@index([kolId, capturedAt])
  @@map("kol_follower_snapshots")
}

// ============================================
// PAYMENTS
// ============================================

enum PaymentStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
}

enum PaymentMethod {
  CRYPTO
  BANK_TRANSFER
  PAYPAL
  OTHER
}

model Payment {
  id           String        @id @default(cuid())
  kolId        String
  campaignId   String?

  amount       Int           // cents
  currency     String        @default("USD")
  method       PaymentMethod @default(CRYPTO)

  status       PaymentStatus @default(PENDING)

  // Crypto payment details
  txHash       String?
  walletAddress String?
  network      String?       // ETH, SOL, etc.

  notes        String?
  paidAt       DateTime?

  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt

  kol      KOL       @relation(fields: [kolId], references: [id], onDelete: Cascade)
  campaign Campaign? @relation(fields: [campaignId], references: [id])

  @@map("payments")
}

// Payment receipts - proof of payment submitted via Telegram
model PaymentReceipt {
  id               String    @id @default(cuid())
  kolId            String
  campaignId       String?

  amount           Int       @default(0)  // Amount in cents (USD)
  proofUrl         String    @unique      // Link to proof - unique to prevent duplicates
  telegramUsername String?   // Who submitted it
  telegramUserId   String?   // Telegram user ID
  notes            String?   // Optional notes

  createdAt        DateTime  @default(now())

  kol              KOL       @relation(fields: [kolId], references: [id], onDelete: Cascade)
  campaign         Campaign? @relation(fields: [campaignId], references: [id])

  @@map("payment_receipts")
}

// ============================================
// TELEGRAM COMMUNICATION
// ============================================

enum MessageDirection {
  INBOUND
  OUTBOUND
}

model TelegramMessage {
  id          String           @id @default(cuid())
  kolId       String

  telegramChatId String
  telegramMessageId String?

  content     String
  direction   MessageDirection

  // Metadata
  senderName  String?
  isRead      Boolean          @default(false)

  timestamp   DateTime         @default(now())
  createdAt   DateTime         @default(now())

  kol KOL @relation(fields: [kolId], references: [id], onDelete: Cascade)

  @@map("telegram_messages")
}

// ============================================
// TELEGRAM GROUP CHAT TRACKING
// ============================================

enum TelegramChatType {
  PRIVATE
  GROUP
  SUPERGROUP
  CHANNEL
}

enum TelegramChatStatus {
  ACTIVE
  LEFT
  KICKED
}

model TelegramChat {
  id                String             @id @default(cuid())
  organizationId    String
  telegramChatId    String             // Telegram's chat ID (can be negative for groups)
  title             String?            // Group name
  type              TelegramChatType   @default(GROUP)
  username          String?            // @groupname if public
  status            TelegramChatStatus @default(ACTIVE)
  memberCount       Int                @default(0)
  botJoinedAt       DateTime           @default(now())
  botLeftAt         DateTime?
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt

  organization      Organization       @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  kolLinks          TelegramChatKOL[]
  messages          TelegramGroupMessage[]

  @@unique([organizationId, telegramChatId])
  @@map("telegram_chats")
}

model TelegramChatKOL {
  id             String   @id @default(cuid())
  chatId         String   // FK to TelegramChat.id
  kolId          String
  telegramUserId String?  // Their Telegram user ID if captured
  matchedBy      String   @default("username") // "username" or "manual"
  createdAt      DateTime @default(now())

  chat           TelegramChat @relation(fields: [chatId], references: [id], onDelete: Cascade)
  kol            KOL          @relation(fields: [kolId], references: [id], onDelete: Cascade)

  @@unique([chatId, kolId])
  @@map("telegram_chat_kols")
}

model TelegramGroupMessage {
  id                String           @id @default(cuid())
  chatId            String           // FK to TelegramChat.id
  telegramMessageId String?
  content           String
  direction         MessageDirection
  senderTelegramId  String?
  senderUsername    String?
  senderName        String?
  replyToMessageId  String?
  timestamp         DateTime         @default(now())
  createdAt         DateTime         @default(now())

  chat              TelegramChat     @relation(fields: [chatId], references: [id], onDelete: Cascade)

  @@index([chatId, timestamp])
  @@map("telegram_group_messages")
}

model TelegramBroadcast {
  id               String    @id @default(cuid())
  organizationId   String
  content          String
  targetType       String    @default("groups") // "groups" or "dms"
  filterType       String    // "all", "met_kpi", "not_met_kpi", "campaign"
  filterCampaignId String?
  targetCount      Int       @default(0)
  sentCount        Int       @default(0)
  failedCount      Int       @default(0)
  status           String    @default("pending") // "pending", "sending", "completed", "failed"
  createdAt        DateTime  @default(now())
  completedAt      DateTime?

  organization     Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  @@map("telegram_broadcasts")
}

// ============================================
// CAMPAIGN JOIN REQUESTS
// ============================================

model CampaignJoinRequest {
  id           String            @id @default(cuid())
  campaignId   String
  kolId        String
  status       JoinRequestStatus @default(PENDING)
  message      String?
  responseNote String?
  createdAt    DateTime          @default(now())
  updatedAt    DateTime          @updatedAt
  respondedAt  DateTime?

  campaign     Campaign          @relation(fields: [campaignId], references: [id], onDelete: Cascade)
  kol          KOL               @relation(fields: [kolId], references: [id], onDelete: Cascade)

  @@unique([campaignId, kolId])
  @@map("campaign_join_requests")
}


// ============================================
// CAMPAIGN DOCUMENTS (Legal Contracts, etc.)
// ============================================

enum DocumentType {
  CONTRACT
  AGREEMENT
  NDA
  INVOICE
  OTHER
}

model CampaignDocument {
  id           String       @id @default(cuid())
  campaignId   String

  name         String       // Display name
  filename     String       // Original filename
  type         DocumentType @default(CONTRACT)
  mimeType     String       @default("application/pdf")
  fileSize     Int          @default(0) // Size in bytes

  // Storage - can be local path or cloud URL
  storagePath  String       // Path to file (local or S3 key)
  storageType  String       @default("local") // "local" or "s3"

  // Metadata
  description  String?
  uploadedBy   String?      // Admin user ID who uploaded

  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt

  campaign     Campaign     @relation(fields: [campaignId], references: [id], onDelete: Cascade)

  @@index([campaignId])
  @@map("campaign_documents")
}

// ============================================
// AUTHENTICATION & SECURITY
// ============================================

// Magic link verification tokens (for passwordless auth)
model VerificationToken {
  id         String   @id @default(cuid())
  identifier String   // Email address
  token      String   @unique
  expires    DateTime
  createdAt  DateTime @default(now())

  @@unique([identifier, token])
  @@index([expires])
  @@map("verification_tokens")
}

// User invitations (for admin-managed access)
model UserInvitation {
  id             String           @id @default(cuid())
  email          String
  organizationId String
  role           OrganizationRole @default(MEMBER)
  invitedBy      String
  token          String           @unique
  expiresAt      DateTime
  acceptedAt     DateTime?
  revokedAt      DateTime?
  createdAt      DateTime         @default(now())

  organization   Organization     @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  inviter        User             @relation("SentInvitations", fields: [invitedBy], references: [id])

  @@index([email])
  @@index([organizationId])
  @@map("user_invitations")
}

// Security audit log for tracking auth events
model SecurityAuditLog {
  id         String   @id @default(cuid())
  userId     String?
  action     String   // LOGIN_SUCCESS, LOGIN_FAILED, MAGIC_LINK_SENT, INVITE_SENT, USER_DISABLED, etc.
  ipAddress  String?
  userAgent  String?
  metadata   Json?    // Additional context (email, reason, etc.)
  createdAt  DateTime @default(now())

  user       User?    @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([userId, createdAt])
  @@index([action, createdAt])
  @@index([ipAddress, createdAt])
  @@map("security_audit_logs")
}
